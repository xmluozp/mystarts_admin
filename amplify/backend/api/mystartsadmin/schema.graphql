# @auth(rules: [{allow:owner, operations: [create,update,delete]}])

# **********************************************************************************
# *****************************************    Phase 1  ****************************
# **********************************************************************************

# ========================================= table
type Tablecount @model {
	tableName: String!
	filter: String
	count: Int
}

# ========================================= user
type User
	@model(mutations: { create: "registerUser", update: "updateUser" })
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{ allow: owner, ownerField: "id" }
			{
				allow: groups
				groups: ["admin"]
				operations: [read, create, update, delete]
			}
		]
	) {
	id: ID!
	email: String!
	familyName: String!
	givenName: String!
	avatar: Picture #强行规定大小，就不用担心preview，节省空间成本
	organizations: [UserOrganization] @connection(name: "UserOrg")
	conversations: [ConversationUser] @connection(name: "UserConv")
	pollitems: [UserBallot] @connection(name: "UserPollitem")
	messages: [Message] @connection(name: "UserMessages")
	videos: [Video] @connection(name: "UserVideo", sortField: "createdAt")
	friends: [User] @connection
	watchs: [User] @connection
}

# ========================================= voting
type Votetopic
	@model
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{ allow: groups, provider: userPools, groups: ["mentor"], operations: [read,update] }
		]
	)
	@key(
		name: "VotetopicWithSort"
		fields: ["type", "createdAt"]
		queryField: "listVotetopicWithSort"
	) {
	id: ID!
	title: String!
	description: String
	voteitems: [Voteitem] @connection(name: "VotetopicItem")

	# for sorting
	type: String!
	createdAt: AWSDateTime!
}

type Voteitem
	@model
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{
				allow: groups
				provider: userPools
				groups: ["admin"]
				operations: [create, read]
			}
		]
	)
	@key(
		name: "VoteitemWithSort"
		fields: ["type", "createdAt"]
		queryField: "listVoteitemWithSort"
	) {
	id: ID!
	title: String!
	votetopic: Votetopic @connection(name: "VotetopicItem")
	isActive: Boolean

	# for sorting
	type: String!
	createdAt: AWSDateTime!
}

type Pollperiod
	@model
	@key(
		name: "PollperiodWithSort"
		fields: ["type", "createdAt"]
		queryField: "listPollperiodWithSort"
	)
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{
				allow: groups
				groups: ["admin"]
				operations: [read, create, update, delete]
			}
		]
	) {
	id: ID!
	title: String!
	description: String
	fromDate: AWSDateTime!
	toDate: AWSDateTime!
	polltopics: [Polltopic] @connection(name: "PollperiodTopic")

	# for sorting
	type: String!
	createdAt: AWSDateTime!
}

type Polltopic
	@model
	@key(
		name: "PolltopicWithSort"
		fields: ["type", "sortNumber"]
		queryField: "listPolltopicWithSort"
	)
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{ allow: groups, groups: ["admin"] }
		]
	) {
	id: ID!
	title: String!
	description: String
	pollperiod: Pollperiod @connection(name: "PollperiodTopic")
	pollitems: [Pollitem] @connection(name: "PolltopicItem")

	# for sorting
	type: String!
	sortNumber: Int
}

type Pollitem
	@model
	@key(
		name: "PollitemWithSort"
		fields: ["type", "sortNumber"]
		queryField: "listPollitemWithSort"
	)
	@auth(
		rules: [
			{ allow: public, provider: iam, operations: [read] }
			{ allow: groups, groups: ["admin"] }
		]
	) {
	id: ID!
	title: String!
	votecount: Int!
	fixcount: Int #admin cheating
	isSuggestion: Boolean
	polltopic: Polltopic @connection(name: "PolltopicItem")
	users: [UserBallot] @connection(name: "PollitemUser")

	# for sorting
	type: String!
	sortNumber: Int
}

# mid table for: user-pollitem
type UserBallot @model(queries: null) {
	id: ID!
	userID: ID!
	user: User! @connection(name: "UserPollitem")
	PollitemID: ID!
	Pollitem: Pollitem! @connection(name: "PollitemUser")
}

# **********************************************************************************
# ***************************************** Phase 2 & 3 ****************************
# **********************************************************************************

# ========================================= organization and inventation

type Invitation @model {
	id: ID!
	# dafaultFriends: [User] @connection #试一下这样存的是不是ID
	# fromUser: User @connection
	inviteToken: String!
}

# 组织
type Organization @model {
	# @auth(
	# 	rules: [
	# 		{ allow: public, operations: [read] }
	# 		{ allow: owner}
	# 		{ allow: groups, groups: ["admin"] },
	# 	]
	# )
	id: ID!
	name: String!
	brief: String
	logo: Picture
	bp: S3Object
	tags: [String] # 可以手动输入
	members: [UserOrganization] @connection(name: "OrgUser")
}

# m2m
type UserOrganization @model(queries: null) {
	id: ID!
	userID: ID!
	user: User! @connection(name: "UserOrg")
	organizationID: ID!
	organization: Organization! @connection(name: "OrgUser")
}

# Tag是搜索用的，纯文本，这个仅作为下拉列表管理用
type Tag @model {
	id: ID!
	name: String!
	isActive: Boolean
}
# ========================================= social
# 留言
# 既然是社交，应该做成像linkedin那样的。实时和留言不要分太清。
# https://www.ctolib.com/aws-samples-aws-appsync-chat.html

# virtual entity, used to connect user with user for messaging
type Conversation
	@model(
		mutations: { create: "createConvo" }
		queries: { get: "getConvo" }
		subscriptions: null
	)
	@auth(rules: [{ allow: owner, ownerField: "members" }]) {
	id: ID!
	messages: [Message] @connection(name: "ConvoMsgs", sortField: "createdAt")
	users: [ConversationUser] @connection(name: "ConvUser")

	# used to set auth
	members: [String!]!
}

# #
type Message
	@model(subscriptions: null, queries: null)
	@auth(rules: [{ allow: owner, ownerField: "authorId" }]) {
	id: ID!
	content: String!
	authorId: String!
	author: User @connection(name: "UserMessages", keyField: "authorId")
	messageConversationId: ID!
	conversation: Conversation! @connection(name: "ConvoMsgs")
	createdAt: AWSDateTime!
}

# m2m
type ConversationUser @model(queries: null) {
	id: ID!
	userID: ID!
	user: User! @connection(name: "UserConv")
	conversationID: ID!
	conversation: Conversation! @connection(name: "ConvUser")
}

# type Subscription {
# 	onCreateConvoLink(convoLinkUserId: ID!): ConvoLink
# 		@aws_subscribe(mutations: ["createConvoLink"])
# 	onCreateMessage(messageConversationId: ID!): Message
# 		@aws_subscribe(mutations: ["createMessage"])
# }

# ======================= notification
type Notification @model {
	id: ID!
	content: String!
	type: String! # announce/remind/message
	action: String! # message, follow, newevent
	receiverID: ID!
	receiver: User! @connection(fields: ["receiverID"])
	sender: User @connection # who triggers the notification
	isRead: Boolean # move to redis later
}

# type NotificationSubscribe @model {
# 	id: ID!
# 	action: String
# 	user: User
# }

# 视频
# 视频是model. 前期主要是外链
type Video @model {
	id: ID!
	name: String!
	brief: String
	url: String!
	preview: Picture
	author: User @connection(name: "UserVideo")
	createdAt: AWSDateTime!
}

# ======================= 用来存储图片，bp之类的
type Picture {
	name: String
	image: S3Object!
	preview: S3Object
}

# 生成preview 需要后台自动
type S3Object {
	bucket: String!
	region: String!
	key: String!
}

# ======================= 暂时不用
# mentor, normal,
# type Role @model {
#     id: ID!
#     permissions: [String!]
#     #fk
#     users: [User] @connection(name: "UserRole")
# }

# type Blog @model {
#   id: ID!
#   name: String!
#   posts: [Post] @connection(keyName: "byBlog", fields: ["id"])
# }

# type Post @model @key(name: "byBlog", fields: ["blogID"]) {
#   id: ID!
#   title: String!
#   blogID: ID!
#   blog: Blog @connection(fields: ["blogID"])
#   comments: [Comment] @connection(keyName: "byPost", fields: ["id"])
# }

# type Comment @model @key(name: "byPost", fields: ["postID", "content"]) {
#   id: ID!
#   postID: ID!
#   post: Post @connection(fields: ["postID"])
#   content: String!
# }
